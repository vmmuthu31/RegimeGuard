Tab 1
Project Name
RegimeGuard
An Explainable AI-Driven Risk-Adaptive Trading Engine for WEEX
Tagline (optional):
AI controls risk, not greed.
________________


1. Project Overview
RegimeGuard is a live AI-powered trading strategy designed for the WEEX exchange that prioritizes capital protection and risk-adjusted performance over speculative gains.
Instead of using AI to predict price direction, RegimeGuard applies artificial intelligence where it has the highest real-world value:
dynamic risk control, exposure management, and regime awareness.
The system combines:
* Market regime classification
* Rule-based execution strategies
* AI-driven risk and drawdown control
This separation ensures transparency, auditability, and robustness while maintaining adaptive behavior across changing market conditions.
________________


2. Problem Statement
Most AI trading systems fail in real markets because they:
* Over-optimize price prediction
* Use excessive leverage
* Ignore regime shifts
* Collapse during volatility spikes or drawdowns
In practice, risk mismanagement, not signal quality, is the primary reason trading strategies fail.
WEEX explicitly discourages gambling-style strategies and favors sustainable, professional systems.
RegimeGuard is built with this philosophy at its core.
________________


3. Solution Summary
RegimeGuard introduces a risk-first trading architecture where:
* AI does not decide trade direction
* AI controls exposure, position sizing, stop-loss logic, and trade frequency
* Market regimes determine which execution logic is allowed
* Volatility anomalies automatically reduce or pause risk
This creates a system that:
* Trades less during unstable conditions
* Scales exposure only when conditions are favorable
* Preserves capital during market stress
________________


4. System Architecture
High-Level Flow
WEEX Market Data
        ↓
Market Regime Classifier (AI)
        ↓
Rule-Based Strategy Selector
        ↓
Risk Control AI Engine
        ↓
Position Sizing & Risk Parameters
        ↓
Trade Execution via WEEX API


Each component has a single responsibility, ensuring explainability and clean evaluation.
________________


5. Market Regime Classification (AI Component #1)
Purpose
Identify the current market environment, not predict price direction.
Regimes
* Trending
* Range-Bound
* High Volatility / Unstable
Inputs
* Price momentum
* Volatility metrics (ATR, realized volatility)
* Volume behavior
* Trend persistence indicators
AI Methods
* Unsupervised clustering / Hidden Markov Models
* Probabilistic regime confidence output
Output Example
Regime: Trending
Confidence: 0.72


This confidence score is later consumed by the risk engine.
________________


6. Strategy Execution Layer (Rule-Based)
Each regime enables only one predefined execution logic.
Market Regime
	Execution Strategy
	Trending
	Trend-following (EMA / VWAP based)
	Range-Bound
	Mean reversion
	High Volatility
	No trade or minimal exposure
	This design choice:
* Prevents overfitting
* Ensures auditability
* Makes trade behavior explainable
________________


7. Risk Control AI Engine (Core Innovation)
This is the primary AI contribution of RegimeGuard.
What the Risk AI Controls
* Position size
* Stop-loss distance
* Trade frequency
* Temporary trade suspension
What It Never Controls
* Buy / sell direction
* Signal generation
Inputs
* Regime confidence
* Volatility forecast
* Recent drawdown
* Trade clustering frequency
* Asset-level risk metrics
Outputs
Position Size Multiplier: 0.35
Stop Loss Adjustment: Tightened
Trade Cooldown: Enabled


The system automatically de-risks when conditions deteriorate.
________________


8. Volatility & Anomaly Guard (AI Component #2)
A dedicated AI module monitors:
* Sudden volatility expansions
* Abnormal price-volume behavior
Behavior
* Reduces exposure aggressively
* Prevents new trades during unstable periods
* Acts as a capital preservation kill-switch
This ensures resilience during flash moves or news-driven shocks.
________________


9. Supported Trading Scope
Exchange
* WEEX only
Trading Pairs
* BTC
* ETH
* SOL
* BNB
* XRP
* ADA
* DOGE
* LTC
Leverage
* Conservative usage
* Always below WEEX limits
* High leverage strategies explicitly avoided
________________


10. AI Participation Description (Submission Section)
Artificial intelligence in RegimeGuard is used selectively and responsibly:
1. Market Regime Classification
AI identifies market conditions using unsupervised learning techniques.
2. Dynamic Risk Management
AI adapts exposure, stop logic, and trade frequency based on real-time risk signals.
3. Volatility Detection
AI predicts volatility expansion and enforces capital protection mechanisms.
AI is not used for speculative price prediction, ensuring stability, transparency, and compliance with fair-play principles.
________________


11. Transparency & Explainability
Every trade is explainable through:
   * Identified market regime
   * Risk engine decision
   * Position sizing rationale
Example explanation:
“Trade executed under trending regime with 72% confidence.
Exposure reduced due to elevated volatility and recent drawdown.”
This meets WEEX’s transparency and open development expectations.
________________


12. GitHub Repository Structure
/strategy
  /regime_classifier
  /risk_engine
  /execution
  /volatility_guard
/docs
  overview.md
  ai_participation.md
  risk_framework.md
  strategy_rules.md
/backtests
/config


All logic is modular and reviewable.
________________


13. Why This Project Fits WEEX Perfectly
   * Aligns with WEEX’s anti-gambling stance
   * Focuses on risk-adjusted performance
   * Suitable for WEEX AI Strategy Fund
   * Institutional, fund-grade architecture
   * Scalable across assets and market cycles
________________


14. Future Expansion (Optional)
   * Capital allocation across multiple WEEX pairs
   * Strategy Fund deployment
   * Long-term incubation as a certified WEEX AI strategy
________________


Final One-Line Summary (Use This in Submissions)
RegimeGuard is an explainable AI-driven trading system where artificial intelligence controls risk exposure and capital preservation, while trading logic remains transparent, disciplined, and investable.
________________


If you want, next I can:
   * Convert this into a one-page submission PDF
   * Write a short pitch for the Popularity Award
   * Help you design safe default parameters
   * Draft README.md + diagrams
Just tell me what you want next.


Tab 2
Project Name
RegimeGuard
An Explainable AI-Driven Risk-Adaptive Trading Engine for WEEX
Tagline (optional):
AI controls risk, not greed.


1. Project Overview
RegimeGuard is a live AI-powered trading strategy designed for the WEEX exchange that prioritizes capital protection and risk-adjusted performance over speculative gains.
Instead of using AI to predict price direction, RegimeGuard applies artificial intelligence where it has the highest real-world value:
dynamic risk control, exposure management, and regime awareness.
The system combines:
Market regime classification
Rule-based execution strategies
AI-driven risk and drawdown control
This separation ensures transparency, auditability, and robustness while maintaining adaptive behavior across changing market conditions.


2. Problem Statement
Most AI trading systems fail in real markets because they:
Over-optimize price prediction
Use excessive leverage
Ignore regime shifts
Collapse during volatility spikes or drawdowns
In practice, risk mismanagement, not signal quality, is the primary reason trading strategies fail.
WEEX explicitly discourages gambling-style strategies and favors sustainable, professional systems.
RegimeGuard is built with this philosophy at its core.


3. Solution Summary
RegimeGuard introduces a risk-first trading architecture where:
AI does not decide trade direction
AI controls exposure, position sizing, stop-loss logic, and trade frequency
Market regimes determine which execution logic is allowed
Volatility anomalies automatically reduce or pause risk
This creates a system that:
Trades less during unstable conditions
Scales exposure only when conditions are favorable
Preserves capital during market stress


4. System Architecture
High-Level Flow
WEEX Market Data
        ↓
Market Regime Classifier (AI)
        ↓
Rule-Based Strategy Selector
        ↓
Risk Control AI Engine
        ↓
Position Sizing & Risk Parameters
        ↓
Trade Execution via WEEX API


Each component has a single responsibility, ensuring explainability and clean evaluation.


5. Market Regime Classification (AI Component #1)
Purpose
Identify the current market environment, not predict price direction.
Regimes
Trending
Range-Bound
High Volatility / Unstable
Inputs
Price momentum
Volatility metrics (ATR, realized volatility)
Volume behavior
Trend persistence indicators
AI Methods
Unsupervised clustering / Hidden Markov Models
Probabilistic regime confidence output
Output Example
Regime: Trending
Confidence: 0.72


This confidence score is later consumed by the risk engine.


6. Strategy Execution Layer (Rule-Based)
Each regime enables only one predefined execution logic.
Market Regime
Execution Strategy
Trending
Trend-following (EMA / VWAP based)
Range-Bound
Mean reversion
High Volatility
No trade or minimal exposure


This design choice:
Prevents overfitting
Ensures auditability
Makes trade behavior explainable


7. Risk Control AI Engine (Core Innovation)
This is the primary AI contribution of RegimeGuard.
What the Risk AI Controls
Position size
Stop-loss distance
Trade frequency
Temporary trade suspension
What It Never Controls
Buy / sell direction
Signal generation
Inputs
Regime confidence
Volatility forecast
Recent drawdown
Trade clustering frequency
Asset-level risk metrics
Outputs
Position Size Multiplier: 0.35
Stop Loss Adjustment: Tightened
Trade Cooldown: Enabled


The system automatically de-risks when conditions deteriorate.


8. Volatility & Anomaly Guard (AI Component #2)
A dedicated AI module monitors:
Sudden volatility expansions
Abnormal price-volume behavior
Behavior
Reduces exposure aggressively
Prevents new trades during unstable periods
Acts as a capital preservation kill-switch
This ensures resilience during flash moves or news-driven shocks.


9. Supported Trading Scope
Exchange
WEEX only
Trading Pairs
BTC
ETH
SOL
BNB
XRP
ADA
DOGE
LTC
Leverage
Conservative usage
Always below WEEX limits
High leverage strategies explicitly avoided


10. AI Participation Description (Submission Section)
Artificial intelligence in RegimeGuard is used selectively and responsibly:
Market Regime Classification
AI identifies market conditions using unsupervised learning techniques.
Dynamic Risk Management
AI adapts exposure, stop logic, and trade frequency based on real-time risk signals.
Volatility Detection
AI predicts volatility expansion and enforces capital protection mechanisms.
AI is not used for speculative price prediction, ensuring stability, transparency, and compliance with fair-play principles.


11. Transparency & Explainability
Every trade is explainable through:
Identified market regime
Risk engine decision
Position sizing rationale
Example explanation:
“Trade executed under trending regime with 72% confidence.
Exposure reduced due to elevated volatility and recent drawdown.”
This meets WEEX’s transparency and open development expectations.


12. GitHub Repository Structure
/strategy
  /regime_classifier
  /risk_engine
  /execution
  /volatility_guard
/docs
  overview.md
  ai_participation.md
  risk_framework.md
  strategy_rules.md
/backtests
/config


All logic is modular and reviewable.


13. Why This Project Fits WEEX Perfectly
Aligns with WEEX’s anti-gambling stance
Focuses on risk-adjusted performance
Suitable for WEEX AI Strategy Fund
Institutional, fund-grade architecture
Scalable across assets and market cycles


14. Future Expansion (Optional)
Capital allocation across multiple WEEX pairs
Strategy Fund deployment
Long-term incubation as a certified WEEX AI strategy


Final One-Line Summary (Use This in Submissions)
RegimeGuard is an explainable AI-driven trading system where artificial intelligence controls risk exposure and capital preservation, while trading logic remains transparent, disciplined, and investable.


If you want, next I can:
Convert this into a one-page submission PDF
Write a short pitch for the Popularity Award
Help you design safe default parameters
Draft README.md + diagrams
Just tell me what you want next.
 help me in bulding this use bun package manager, shadcn, jotai atoms, react-queryAI Wars: WEEX Alpha Awakens
AI Wars APIs allow developers and traders to connect their applications, bots, or automated systems to financial markets. These APIs provide market data, trade execution, and account management.


Trading rules
All trading must be conducted through the official WEEX OpenAPI platform using accounts approved for the competition.


Only the designated trading pairs announced for the competition are permitted for trading. cmt_btcusdt, cmt_ethusdt, cmt_solusdt, cmt_dogeusdt, cmt_xrpusdt, cmt_adausdt, cmt_bnbusdt,cmt_ltcusdt


Any trades outside the approved scope will result in immediate disqualification.


Trading strategies may be fully or semi-automated, but purely manual trading is strictly prohibited.


The following actions are prohibited and will lead to disqualification:


Profiting from high-frequency or latency arbitrage, wash trading, or market manipulation.
Altering data, falsifying trading records, or fabricating AI logs.
Sharing, borrowing, or transferring API keys or trading accounts.
Engaging in purely manual trading without the use of genuine AI technology.
Any participant found attempting to gain an unfair advantage through deceptive or manipulative means will be disqualified, and their ranking will be voided.


The organizer reserves the right to implement or adjust risk control measures (including maximum leverage, position limits, order frequency limits, STP, rate limiting, and liquidation protection mechanisms) and may enforce position closures to manage risk or comply with legal and regulatory requirements.


2.2 Connect and Test
Participants need to complete a simple API test to qualify for the preliminary round of the hackathon. Please read the WEEX official API documentation carefully, and use the API key we provide to complete the test.


tip
API-testing: Use the API to call the order placement endpoint and execute a trade for approximately 10 USDT on cmt_btcusdt.


Integration Preparation
Please read the official WEEX API documentation carefully: https://www.weex.com/api-doc/ai/intro


Connect to a cloud server and run the code below. You should receive a response that confirms whether your network connection is working properly.


curl -s --max-time 10 "https://api-contract.weex.com/capi/v2/market/time"


{"epoch":"1765423487.896","iso":"2025-12-11T03:24:47.896Z","timestamp":1765423487896}


If your project is developed in Java or Python, you can directly use the corresponding code examples provided in the documentation. For other programming languages, please adapt the examples according to the official API documentation to suit your implementation. Sample code documentation: https://www.weex.com/api-doc/ai/QuickStart/RequestInteraction


The platform provides two types of APIs:


Public APIs: Used to access configuration details, market data, and other public information. No authentication is required.
Private APIs: Used for order management, account operations, and other sensitive actions. Authentication is mandatory.
When calling private APIs, please include the following authentication details in your HTTP request headers:


Request Header Fields        Information
ACCESS-KEY        A unique identifier for the user account
ACCESS-PASSPHRASE        The password associated with the API Key
ACCESS-TIMESTAMP        A Unix Epoch timestamp in milliseconds. The timestamp is valid for 30 seconds and must match the one used in the signature calculation.
ACCESS-SIGN        The request signature string. You may use the signature generation method provided in the sample code. For the underlying algorithm, refer to the signature documentation: https://www.weex.com/api-doc/ai/QuickStart/Signature
Content-Type        Content fixed as application/json.
locale        Language identifier (e.g.,zh-CN,en-US)
Fill in "https://api-contract.weex.com" for BASE_URL


HTTP status codes:


200 Success – Successful response
400 Bad Request – Invalid request format
403 Forbidden – You do not have access to the requested resource
404 Not Found – Request not found
429 Too Many Requests – Request too frequent, please try again later
500 Internal Server Error – We had a problem with our server
521 Web Server is Down – IP not whitelisted
Other error codes：https://www.weex.com/api-doc/contract/ErrorCodes/ExampleOfErrorCode


You can start API testing once the above steps are completed. The following instructions use BTC as the example asset.


Check Account Balance
Use Account Balance API to request your current account balance
Sample code:




import time
import hmac
import hashlib
import base64
import requests


api_key = ""
secret_key = ""
access_passphrase = ""


def generate_signature_get(secret_key, timestamp, method, request_path, query_string):
  message = timestamp + method.upper() + request_path + query_string
  signature = hmac.new(secret_key.encode(), message.encode(), hashlib.sha256).digest()
  return base64.b64encode(signature).decode()


def send_request_get(api_key, secret_key, access_passphrase, method, request_path, query_string):
  timestamp = str(int(time.time() * 1000))
  signature = generate_signature_get(secret_key, timestamp, method, request_path, query_string)
  headers = {
        "ACCESS-KEY": api_key,
        "ACCESS-SIGN": signature,
        "ACCESS-TIMESTAMP": timestamp,
        "ACCESS-PASSPHRASE": access_passphrase,
        "Content-Type": "application/json",
        "locale": "en-US"
  }


  url = "https://api-contract.weex.com/"  # Please replace with the actual API address
  if method == "GET":
    response = requests.get(url + request_path+query_string, headers=headers)
  return response


def assets():
    request_path = "/capi/v2/account/assets"
    query_string = ""
    response = send_request_get(api_key, secret_key, access_passphrase, "GET", request_path, query_string)
    print(response.status_code)
    print(response.text)


if __name__ == '__main__':
    assets()




Check the response
The example below indicates a successful response


[
  {
    "coinName": "USDT",
    "available": "5413.06877369",
    "equity": "5696.49288823",
    "frozen": "81.28240000",
    "unrealizePnl": "-34.55300000"
  }
]


If the request fails, refer to the detailed error codes here, or contact technical support in the TG group.


Get Asset Price
1.Use Price Ticker API to request the latest price of cmt_btcusdt


Sample code:


import requests


def send_request_get( method, request_path, query_string):
  url = "https://api-contract.weex.com/"  # Please replace with the actual API address
  if method == "GET":
    response = requests.get(url + request_path+query_string)
  return response


def ticker():
    request_path = "/capi/v2/market/ticker"
    query_string = "?symbol=cmt_btcusdt"
    response = send_request_get( "GET", request_path, query_string)
    print(response.status_code)
    print(response.text)


if __name__ == '__main__':
    ticker()


Check the response
The example below indicates a successful response


{
  "symbol": "cmt_btcusdt",
  "last": "90755.3",
  "best_ask": "90755.4",
  "best_bid": "90755.3",
  "high_24h": "91130.0",
  "low_24h": "90097.3",
  "volume_24h": "2321170547.37995",
  "timestamp": "1764482511864",
  "priceChangePercent": "0.000474",
  "base_volume": "25615.0755",
  "markPrice": "90755.2",
  "indexPrice": "90797.161"
}


If the request fails, refer to the detailed error codes here, or contact technical support in the TG group.


Set Leverage
Note: The maximum leverage allowed in this competition is 20x; please follow the rules on WEEX official website.


Use the Leverage Adjustment API to modify the cross-margin leverage for cmt_btcusdt
Sample code:


import time
import hmac
import hashlib
import base64
import requests
import json


api_key = ""
secret_key = ""
access_passphrase = ""


def generate_signature(secret_key, timestamp, method, request_path, query_string, body):
  message = timestamp + method.upper() + request_path + query_string + str(body)
  signature = hmac.new(secret_key.encode(), message.encode(), hashlib.sha256).digest()
  return base64.b64encode(signature).decode()


def send_request_post(api_key, secret_key, access_passphrase, method, request_path, query_string, body):
  timestamp = str(int(time.time() * 1000))
  body = json.dumps(body)
  signature = generate_signature(secret_key, timestamp, method, request_path, query_string, body)
  headers = {
        "ACCESS-KEY": api_key,
        "ACCESS-SIGN": signature,
        "ACCESS-TIMESTAMP": timestamp,
        "ACCESS-PASSPHRASE": access_passphrase,
        "Content-Type": "application/json",
        "locale": "en-US"
  }
  url = "https://api-contract.weex.com/"  # Please replace with the actual API address
  if method == "POST":
    response = requests.post(url + request_path, headers=headers, data=body)
  return response


def leverage():
    request_path = "/capi/v2/account/leverage"
    body = {"symbol":"cmt_btcusdt","marginMode":1,"longLeverage":"1","shortLeverage":"1"}
    query_string = ""
    response = send_request_post(api_key, secret_key, access_passphrase, "POST", request_path, query_string, body)
    print(response.status_code)
    print(response.text)


if __name__ == '__main__':
    leverage()




You may set other leverage values (up to 20×) in the same way—simply replace the leverage numbers accordingly. The leverage values are followed by the trading pairs.


2.Check the response


The example below indicates a successful response


{
    "msg": "success",
    "requestTime": 1713339011237,
    "code": "200"
}


If the request fails, refer to the detailed error codes here, or contact technical support in the TG group.


Place order
Note: Only the following trading pairs are allowed in this competition: cmt_btcusdt, cmt_ethusdt, cmt_solusdt, cmt_dogeusdt, cmt_xrpusdt, cmt_adausdt, cmt_bnbusdt, cmt_ltcusdt


The maximum leverage is 20x; please follow the rules on WEEX official website.


1.Use Get Futures Information to retrieve contract information for cmt_btcusdt (order precision, price precision, max/min order size, etc.)


Sample code:


import requests


def send_request_get( method, request_path, query_string):
  url = "https://api-contract.weex.com/"  # Please replace with the actual API address
  if method == "GET":
    response = requests.get(url + request_path+query_string)
  return response


def contracts():
    request_path = "/capi/v2/market/contracts"
    query_string = "?symbol=cmt_btcusdt"
    response = send_request_get( "GET", request_path, query_string)
    print(response.status_code)
    print(response.text)


if __name__ == '__main__':
    contracts()


2.Check the response


The example below indicates a successful response


[
  {
    "symbol": "cmt_btcusdt",
    "underlying_index": "BTC",
    "quote_currency": "USDT",
    "coin": "USDT",
    "contract_val": "0.0001",
    "delivery": [
      "00:00:00",
      "08:00:00",
      "16:00:00"
    ],
    "size_increment": "4",
    "tick_size": "1",
    "forwardContractFlag": true,
    "priceEndStep": 1,
    "minLeverage": 1,
    "maxLeverage": 400,
    "buyLimitPriceRatio": "0.01",
    "sellLimitPriceRatio": "0.01",
    "makerFeeRate": "0.0002",
    "takerFeeRate": "0.0008",
    "minOrderSize": "0.0001",
    "maxOrderSize": "1200",
    "maxPositionSize": "1000000",
    "marketOpenLimitSize": "100"
  }
]


If the request fails, refer to the detailed error codes here, or contact technical support in the TG group.


Note: The API response may show a higher maximum leverage (for example, 400x) available on the platform. However, for this competition, the maximum leverage you are allowed to use is strictly limited to 20x.


Use Place Order API to open a long position for cmt_btcusdt with a limit price of 100000.0 and 0.0001 BTC, using the contract information from Step 1 (order precision, price precision, and max/min order size) to construct the parameters.
Sample code:


import time
import hmac
import hashlib
import base64
import requests
import json


api_key = ""
secret_key = ""
access_passphrase = ""


def generate_signature(secret_key, timestamp, method, request_path, query_string, body):
  message = timestamp + method.upper() + request_path + query_string + str(body)
  signature = hmac.new(secret_key.encode(), message.encode(), hashlib.sha256).digest()
  return base64.b64encode(signature).decode()


def send_request_post(api_key, secret_key, access_passphrase, method, request_path, query_string, body):
  timestamp = str(int(time.time() * 1000))
  body = json.dumps(body)
  signature = generate_signature(secret_key, timestamp, method, request_path, query_string, body)
  headers = {
        "ACCESS-KEY": api_key,
        "ACCESS-SIGN": signature,
        "ACCESS-TIMESTAMP": timestamp,
        "ACCESS-PASSPHRASE": access_passphrase,
        "Content-Type": "application/json",
        "locale": "en-US"
  }
  url = "https://api-contract.weex.com/"  # Please replace with the actual API address
  if method == "POST":
    response = requests.post(url + request_path, headers=headers, data=body)
  return response


def placeOrder():
    request_path = "/capi/v2/order/placeOrder"
    body = {
        "symbol": "cmt_btcusdt",
        "client_oid": "test",
        "size": "0.0001",
        "type": "1",
        "order_type": "0",
        "match_price": "0",
        "price": "100000.0"}
    query_string = ""
    response = send_request_post(api_key, secret_key, access_passphrase, "POST", request_path, query_string, body)
    print(response.status_code)
    print(response.text)


if __name__ == '__main__':
    placeOrder()




Check the response
The example below indicates a successful response


{
        "client_oid": null,
        "order_id": "596471064624628269"
}


If the request fails, refer to the detailed error codes here, or contact technical support in the TG group.


Get Trade Details for Completed Orders
1.Use Trade Details API to retrieve your trade history.


Sample code:


import time
import hmac
import hashlib
import base64
import requests


api_key = ""
secret_key = ""
access_passphrase = ""


def generate_signature_get(secret_key, timestamp, method, request_path, query_string):
  message = timestamp + method.upper() + request_path + query_string
  signature = hmac.new(secret_key.encode(), message.encode(), hashlib.sha256).digest()
  return base64.b64encode(signature).decode()


def send_request_get(api_key, secret_key, access_passphrase, method, request_path, query_string):
  timestamp = str(int(time.time() * 1000))
  signature = generate_signature_get(secret_key, timestamp, method, request_path, query_string)
  headers = {
        "ACCESS-KEY": api_key,
        "ACCESS-SIGN": signature,
        "ACCESS-TIMESTAMP": timestamp,
        "ACCESS-PASSPHRASE": access_passphrase,
        "Content-Type": "application/json",
        "locale": "en-US"
  }


  url = "https://api-contract.weex.com/"  # Please replace with the actual API address
  if method == "GET":
    response = requests.get(url + request_path+query_string, headers=headers)
  return response


def fills():
    request_path = "/capi/v2/order/fills"
    query_string = "?symbol=cmt_btcusdt&orderId=YOUR_ORDER_ID"
    response = send_request_get(api_key, secret_key, access_passphrase, "GET", request_path, query_string)
    print(response.status_code)
    print(response.text)
if __name__ == '__main__':
    fills()




2.Check the response


The example below indicates a successful response


{
  "list": [
    {
      "tradeId": 0,
      "orderId": 0,
      "symbol": "cmt_btcusdt",
      "marginMode": "SHARED",
      "separatedMode": "SEPARATED",
      "positionSide": "LONG",
      "orderSide": "BUY",
      "fillSize": "67",
      "fillValue": "12",
      "fillFee": "67",
      "liquidateFee": "MAKER",
      "realizePnl": "83",
      "direction": "OPEN_LONG",
      "liquidateType": "FORCE_LIQUIDATE",
      "legacyOrdeDirection": "OPEN_LONG",
      "createdTime": 1716712170527
    }
  ],
  "nextFlag": false,
  "totals": 0
}


If the request fails, refer to the detailed error codes here, or contact technical support in the TG group.


Our customer support team will contact you once you pass the testing.


2.3 Funding & Model Testing
Once you have completed API testing and passed the qualification review, your account will receive the initial funds required for AI model testing. You may freely use these funds until January 5, 2026 to optimize your AI model.


If you encounter any technical issues or run out of test funds, please contact our official technical support group for assistance.


2.4 Pre-Competition Preparation & Account Reset
After the model testing phase, the official list of participants will be published, so please stay updated via the official participant list on the event page. To ensure fairness before the official competition begins, all participant accounts will be reset to a unified initial state, with your competition fund balances reset to 1,000 USDT, all open orders canceled, and all positions closed.


At this point, all pre-competition preparations are complete. Ensure your AI model is fully integrated with your API Key and ready to trade immediately once the competition begins.


Note: All official announcements, participant lists, and rule updates will be published on the WEEX official event page. Detailed schedules, ranking rules, and risk management terms will be provided in the official Competition Rules Handbook or via separate notices before the event.


Preparation
To use the API,please register for the AI Wars: WEEX Alpha Awakens.


Once the team passes the review, staff will provide you with an API Key, This document explains how to properly use the AI Wars API.


You may use your own AI models to run algorithmic analysis, generate trading strategies, and execute strategy-based orders.


WEEX provides the API endpoints that allow you to perform actual trading actions in the market, such as placing orders, adjusting leverage, and managing positions.


Make sure to securely store the following information:


APIKey — The unique identifier for API authentication which is algorithmically generated.
SecretKey — The system-generated private key for signature encryption.
Passphrase —A access phrase.
API Types
This section categorizes APIs into two types:


Public APIs
Private APIs
Public APIs


Public APIs allow users to retrieve configuration and market data.These requests do not require authentication.


Private APIs


Private APIs enable order management and account management.Each private request must be authenticated using a standardized signature method.


Private APIs require validation with your API key.


LIMITS
API keys have rate limits. Exceeding them returns error 429: Too many requests. The account is used as the basic unit of speed limit for the endpoints that need to carry an API key. For endpoints that do not need to carry an API key, IP addresses are used as the basic unit of rate limiting.


Limits description


IP-based and UID-based limits operate independently.


Each endpoint indicates whether it follows IP or UID limits, along with its weight value.


Endpoints with IP limits have an independent limit of 1000 requests per 10 seconds.


Endpoints with UID limits also have an independent limit of 1000 requests per 10 seconds.


Special Interface Description


The interfaces for Place Order, Cancel Order, Place Trigger Order, and Cancel Trigger Order are limited to a maximum of 10 requests per second.


Limits error


When a 429 error occurs, make sure to stop sending excessive requests.


API Domain
You can use different domain as below Rest API.


Domain Name        API        Description
REST Domain        https://api-contract.weex.com        Main Domain
Signature
The ACCESS-SIGN request header is generated by using the HMAC SHA256 method encryption on the timestamp + method.toUpperCase() + requestPath + "?" + queryString + body string (+ denotes string concatenation), and putting the result through BASE64 encoding.


Signature Field Description


timestamp: This matches the ACCESS-TIMESTAMP header.
method: The request method (POST/GET), with all letters in uppercase.
requestPath: API endpoint path.
queryString: The query parameters after the "?" in the URL.
body: The string that corresponds to the request body (omitted if empty, typically for GET requests).
Signature format rules if queryString is empty


timestamp + method.toUpperCase() + requestPath + body
Signature format rules if queryString is not empty


timestamp + method.toUpperCase() + requestPath + "?" + queryString + body
Examples


Fetching market depth, using BTCUSDT as an example:


Timestamp = 1591089508404
Method = "GET"
requestPath = "/capi/v2/market/candles"
queryString= "?symbol=cmt_btcusdt&limit=20"
Generate the string to be signed:


'1591089508404GET/api/v2/market/depth?symbol=cmt_btcusdt&limit=20'
Placing an order, using cmt_btcusdt as an example:


Timestamp = 1561022985382


Method = "POST"


requestPath = "/capi/v2/order/placeOrder"


body =


{"symbol":"cmt_btcusdt","quantity":"8","side":"buy","price":"1","orderType":"limit","clientOrderId":"ww#123456"}




Generate the string to be signed:


'1561022985382POST/capi/v2/order/placeOrder{"symbol":"cmt_btcusdt","size":"8","side":"buy","price":"1","orderType":"limit","clientOrderId":"ww#123456"}'




Steps to generate the final signature


Encrypt the unsigned string with HMAC SHA256 using your secretKey
Signature = hmac_sha256(secretkey, Message)
Encode the signature using Base64
Signature = base64.encode(Signature)
Demo Code
Java
Python
import time
import hmac
import hashlib
import base64
import requests
import json


api_key = ""
secret_key = ""
access_passphrase = ""




def generate_signature(secret_key, timestamp, method, request_path, query_string, body):
  message = timestamp + method.upper() + request_path + query_string + str(body)
  signature = hmac.new(secret_key.encode(), message.encode(), hashlib.sha256).digest()
  # print(base64.b64encode(signature).decode())
  return base64.b64encode(signature).decode()




def generate_signature_get(secret_key, timestamp, method, request_path, query_string):
  message = timestamp + method.upper() + request_path + query_string
  signature = hmac.new(secret_key.encode(), message.encode(), hashlib.sha256).digest()
  # print(base64.b64encode(signature).decode())
  return base64.b64encode(signature).decode()




def send_request_post(api_key, secret_key, access_passphrase, method, request_path, query_string, body):
  timestamp = str(int(time.time() * 1000))
  # print(timestamp)
  body = json.dumps(body)
  signature = generate_signature(secret_key, timestamp, method, request_path, query_string, body)


  headers = {
        "ACCESS-KEY": api_key,
        "ACCESS-SIGN": signature,
        "ACCESS-TIMESTAMP": timestamp,
        "ACCESS-PASSPHRASE": access_passphrase,
        "Content-Type": "application/json",
        "locale": "en-US"
  }


  url = "https://api-contract.weex.com/"  # Please replace with the actual API address
  if method == "GET":
    response = requests.get(url + request_path, headers=headers)
  elif method == "POST":
    response = requests.post(url + request_path, headers=headers, data=body)
  return response


def send_request_get(api_key, secret_key, access_passphrase, method, request_path, query_string):
  timestamp = str(int(time.time() * 1000))
  # print(timestamp)
  signature = generate_signature_get(secret_key, timestamp, method, request_path, query_string)


  headers = {
        "ACCESS-KEY": api_key,
        "ACCESS-SIGN": signature,
        "ACCESS-TIMESTAMP": timestamp,
        "ACCESS-PASSPHRASE": access_passphrase,
        "Content-Type": "application/json",
        "locale": "en-US"
  }


  url = "https://api-contract.weex.com/"  # Please replace with the actual API address
  if method == "GET":
    response = requests.get(url + request_path+query_string, headers=headers)
  return response


def get():
    # Example of calling a GET request
    request_path = "/capi/v2/account/position/singlePosition"
    query_string = '?symbol=cmt_btcusdt'
    response = send_request_get(api_key, secret_key, access_passphrase, "GET", request_path, query_string)
    print(response.status_code)
    print(response.text)


def post():
    # Example of calling a POST request
    request_path = "/capi/v2/order/placeOrder"
    body = {
        "symbol": "cmt_btcusdt",
        "client_oid": "71557515757447",
        "size": "0.01",
        "type": "1",
        "order_type": "0",
        "match_price": "1",
        "price": "80000"}
    query_string = ""
    response = send_request_post(api_key, secret_key, access_passphrase, "POST", request_path, query_string, body)
    print(response.status_code)
    print(response.text)


if __name__ == '__main__':
    get()
    post()




All requests are based on the HTTPS protocol. The Content-Type in the request headers must be set to 'application/json'.


Request Processing


Request parameters: Parameter encapsulation according to endpoint request parameter specification.
Submit request: Submit the encapsulated parameters to the server via GET/POST.
Server response: The server first performs security checks on the request data, and after passing the check, returns the response data to the user in the JSON format based on the operation logic.
Data processing: Process the server response data.
Success


HTTP 200 status codes indicates success and may contain content.Response content (if any) will be included in the returned data.


Common error codes


400 Bad Request – Invalid request format
401 Unauthorized – Invalid API Key
403 Forbidden – You do not have access to the requested resource
404 Not Found — No requests found
429 Too Many Requests – Rate limit exceeded
500 Internal Server Error – We had a problem with our server
Failed responses include error descriptions in the body.
Standard Specifications
Timestamp


The ACCESS-TIMESTAMP in request signatures is in milliseconds.Requests are rejected if the timestamp deviates by over 30 seconds from the API server time. If the local server time deviates significantly from the API server time, we recommend updating the HTTP header by querying the API server time.


Request formats


Only two request methods are supported: GET and POST


GET: Parameters are sent via queryString in the path to the server.
POST: Parameters are sent as a JSON-formatted body to the server.
Previous
Demo Code
Next